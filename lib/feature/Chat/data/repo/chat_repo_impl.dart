import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:dartz/dartz.dart';
import '../../../../core/utils/Failure/failure.dart';
import '../../../../core/utils/firebase/firebase.dart';
import '../model/chat_message.dart';
import '../model/chat_user.dart';
import 'chat_repo.dart';

class ChatRepositoryImpl implements ChatRepository {
  final FirebaseConsumer _firebaseConsumer;

  const ChatRepositoryImpl(this._firebaseConsumer);

  @override
  Stream<Either<Failure, List<ChatMessage>>> getMessages({
    required String conversationId,
  }) {
    return _firebaseConsumer.getSubcollection<ChatMessage>(
      parentPath: 'conversations/$conversationId',
      subcollectionName: 'messages',
      fromJson: ChatMessage.fromJson,
      orderBy: 'timestamp',
      descending: true,
    );
  }

  @override
  Future<Either<Failure, String>> sendMessage({
    required String conversationId,
    required String senderId,
    required String receiverId,
    required String content,
    required String senderName,
    required String receiverName,
    String type = 'text',
    String? senderProfilePic,
    String? receiverProfilePic,
  }) async {
    try {
      final now = Timestamp.now();
      final message = ChatMessage(
        id: '', // Will be generated by Firestore
        senderId: senderId,
        receiverId: receiverId,
        content: content,
        timestamp: now.toDate(),
        type: MessageType.values.firstWhere(
          (e) => e.name == type,
          orElse: () => MessageType.text,
        ),
        isRead: false,
      );

      // Add message to messages subcollection
      final result = await _firebaseConsumer.addToSubcollection(
        parentPath: 'conversations/$conversationId',
        subcollectionName: 'messages',
        data: message.toJson()..addAll({'timestamp': now}),
      );

      return result.fold((failure) => Left(failure), (messageId) async {
        // Prepare global conversation meta-data
        final conversationData = {
          'lastMessage': content,
          'lastMessageTime': now,
          'lastMessageSenderId': senderId,
          'members': [senderId, receiverId],
        };

        // Prepare sender's local inbox entry
        final senderConversation = {
          'id': conversationId,
          'otherUserId': receiverId,
          'otherUserName': receiverName,
          'otherUserProfilePic': receiverProfilePic,
          'lastMessage': content,
          'lastMessageTime': now,
          'unreadCount': 0,
        };

        // Prepare receiver's local inbox entry
        final receiverConversation = {
          'id': conversationId,
          'otherUserId': senderId,
          'otherUserName': senderName,
          'otherUserProfilePic': senderProfilePic,
          'lastMessage': content,
          'lastMessageTime': now,
        };

        await _firebaseConsumer.setDocument(
          path: 'conversations/$conversationId',
          data: conversationData,
          merge: true,
        );

        await _firebaseConsumer.setDocument(
          path: 'userConversations/$senderId/contacts/$receiverId',
          data: senderConversation,
          merge: true,
        );

        await _firebaseConsumer.setDocument(
          path: 'userConversations/$receiverId/contacts/$senderId',
          data: receiverConversation,
          merge: true,
        );

        return Right(messageId);
      });
    } catch (e) {
      return Left(FirebaseFailure('Error sending message: $e'));
    }
  }

  @override
  Future<Either<Failure, void>> markMessageAsRead({
    required String conversationId,
    required String messageId,
  }) {
    return _firebaseConsumer.updateDocument(
      path: 'conversations/$conversationId/messages/$messageId',
      data: {'isRead': true},
    );
  }

  @override
  Stream<Either<Failure, List<ChatUser>>> getContacts() {
    return _firebaseConsumer.getCollection<ChatUser>(
      path: 'userConversations/admin/contacts',
      fromJson: ChatUser.fromJson,
      orderBy: 'lastMessageTime',
      descending: true,
    );
  }

  @override
  Stream<Either<Failure, List<ChatUser>>> getUsers() {
    return _firebaseConsumer.getCollection<ChatUser>(
      path: 'Users',
      fromJson: ChatUser.fromJson,
      orderBy: 'name',
    );
  }
}
